hal(64): 20.09-s001: (c) Copyright 1995-2020 Cadence Design Systems, Inc.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
hal: Options:   -gui main.v LFSR.v MISR.v Bist_Control.v circuito_scan_syn.v.
hal: Workspace: /afs/.ist.utl.pt/users/9/0/ist193790/FTSE/proj_2.
hal: Date: Fri Jan 05 15:28:35 WET 2024.

hal: Running on design source files.....
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
hal: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
hal: Snapshot:  worklib.main:v.
hal: *W,PRTSNP: Design is partially elaborated. Connectivity information may not be complete.

  ==========================================================================
Compiling design 


INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xmvlog: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xrun: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
xmelab: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
xmelab: *N,CUVBPD: instance main.circuito_scan.\fs_state_reg[2]  of design unit 'DFS1' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.\fs_state_reg[1]  of design unit 'JKS3' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g935__2398 of design unit 'OAI310' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g937__5107 of design unit 'NAND20' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g938 of design unit 'INV2' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g940__6260 of design unit 'AOI221' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.\fs_state_reg[0]  of design unit 'DFS1' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g939__4319 of design unit 'NOR30' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g942 of design unit 'INV0' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g943__8428 of design unit 'AOI220' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g944__5526 of design unit 'NOR21' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g945 of design unit 'INV2' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g946__6783 of design unit 'AOI210' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g947__3680 of design unit 'NOR31' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g949__1617 of design unit 'NAND22' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g948__2802 of design unit 'NOR20' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g950__1705 of design unit 'IMUX21' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g951 of design unit 'INV0' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g953__5122 of design unit 'NAND20' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g952__8246 of design unit 'NAND20' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g955 of design unit 'INV3' is unresolved in 'worklib.circuito12_scan:v'.
xmelab: *N,CUVBPD: instance main.circuito_scan.g954 of design unit 'INV2' is unresolved in 'worklib.circuito12_scan:v'.
	Top level design units:
		main

  ==========================================================================
Performing lint checks 

halcheck(64): 20.09-s001: (c) Copyright 1995-2020 Cadence Design Systems, Inc.
INCLUDE $AMS_DIR/cds/HK_ALL/env/cds.lib
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B3   $AMS_DIR/cds/HK_C35/TECH_C35B3
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.
DEFINE PRIMLIB      $AMS_DIR/cds/HK_C35/PRIMLIB
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.
DEFINE ESDLIB       $AMS_DIR/cds/HK_C35/ESDLIB
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.
DEFINE GATES        $AMS_DIR/cds/HK_C35/GATES
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.
DEFINE CORELIBD     $AMS_DIR/cds/HK_C35/CORELIBD
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.
DEFINE TECH_C35B4   $AMS_DIR/cds/HK_C35/TECH_C35B4
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.
DEFINE LEADFRAMES    $AMS_DIR/cds/HK_ALL/LEADFRAMES
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.
DEFINE PACKAGES   $AMS_DIR/cds/HK_ALL/PACKAGES
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.
DEFINE BORDERS   $AMS_DIR/cds/HK_ALL/BORDERS
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.
DEFINE sbaLib    $CDSDIR/tools/dfII/etc/cdslib/artist/sbaLib
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.
DEFINE SFCLIB_C35B4C0 $AMS_DIR/cds/HK_C35/SFCLIB_C35B4C0
|
halcheck: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.
visadev(64): 20.09-s001: (c) Copyright 1995-2020 Cadence Design Systems, Inc.
visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.

module main(CLK,RST,bist_start,bist_end,pass_fail,in_k,in_j,in_en,out_synced_d,out_sync_err_d);
|
halcheck: *N,PRTCNT (./main.v,3|0): Module/Entity 'main' contains '10' ports.
halcheck: (./main.v,3): Number of Input ports: 6.
halcheck: (./main.v,3): Number of Output ports: 4.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halcheck: *W,UNCONN (./main.v,18|0): Output port 'RUNNING' defined in design-unit 'Bist_control' is not connected in its instance 'Bist'.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halcheck: *W,UNCONN (./main.v,18|0): Output port 'INIT' defined in design-unit 'Bist_control' is not connected in its instance 'Bist'.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halcheck: *W,UNCONN (./main.v,18|0): Output port 'FINISH' defined in design-unit 'Bist_control' is not connected in its instance 'Bist'.
`timescale 1ns / 1ps
|
halcheck: *W,CTLCHR (./main.v,1|0): HDL source line contains one or more control characters.
`timescale 1ns / 1ps
|
halcheck: *N,CDNOTE (./main.v,1|0): The compiler directive '`timescale' is used in the RTL.

|
halcheck: *W,CTLCHR (./main.v,2|0): HDL source line contains one or more control characters.
module main(CLK,RST,bist_start,bist_end,pass_fail,in_k,in_j,in_en,out_synced_d,out_sync_err_d);
|
halcheck: *W,CTLCHR (./main.v,3|0): HDL source line contains one or more control characters.
module main(CLK,RST,bist_start,bist_end,pass_fail,in_k,in_j,in_en,out_synced_d,out_sync_err_d);
|
halcheck: *W,MAXLEN (./main.v,3|0): The HDL source line is 96 characters, which exceeds the recommended length of 80 characters.
input CLK,RST,bist_start,in_k,in_j,in_en;
|
halcheck: *W,CTLCHR (./main.v,4|0): HDL source line contains one or more control characters.
output reg pass_fail;
|
halcheck: *W,CTLCHR (./main.v,5|0): HDL source line contains one or more control characters.
output wire bist_end, out_synced_d, out_sync_err_d;
|
halcheck: *W,CTLCHR (./main.v,6|0): HDL source line contains one or more control characters.
wire bist_out; //Registros para o Bist
|
halcheck: *W,CTLCHR (./main.v,7|0): HDL source line contains one or more control characters.
reg circ_k,circ_j,circ_en; //Registros para o circuito
|
halcheck: *W,CTLCHR (./main.v,8|0): HDL source line contains one or more control characters.
wire in_x0,in_x1,in_x2; //Registro para o LFSR
|
halcheck: *W,CTLCHR (./main.v,9|0): HDL source line contains one or more control characters.
wire scan_out;
|
halcheck: *W,CTLCHR (./main.v,10|0): HDL source line contains one or more control characters.
wire h0,h1,h2; //registros misr
|
halcheck: *W,CTLCHR (./main.v,11|0): HDL source line contains one or more control characters.
reg [7:0] count; //Conferir contador do pass_fail
|
halcheck: *W,CTLCHR (./main.v,12|0): HDL source line contains one or more control characters.
wire s2,s1,s0; //Registros do signature
|
halcheck: *W,CTLCHR (./main.v,13|0): HDL source line contains one or more control characters.
//circuito12 circuito (.clk(CLK),.rst(RST),.k(circ_k),.j(circ_j),.rx_en(circ_en),.synced_d(out_synced_d),.sync_err_d(out_sync_err_d));
|
halcheck: *W,CTLCHR (./main.v,14|0): HDL source line contains one or more control characters.
//circuito12 circuito (.clk(CLK),.rst(RST),.k(circ_k),.j(circ_j),.rx_en(circ_en),.synced_d(out_synced_d),.sync_err_d(out_sync_err_d));
|
halcheck: *W,MAXLEN (./main.v,14|0): The HDL source line is 135 characters, which exceeds the recommended length of 80 characters.
circuito12_scan circuito_scan(.clk(CLK),.rst(RST),.k(circ_k),.j(circ_j),.rx_en(circ_en),.synced_d(out_synced_d),.sync_err_d(out_sync_err_d), .scan_en(bist_out),
|
halcheck: *W,CTLCHR (./main.v,15|0): HDL source line contains one or more control characters.
circuito12_scan circuito_scan(.clk(CLK),.rst(RST),.k(circ_k),.j(circ_j),.rx_en(circ_en),.synced_d(out_synced_d),.sync_err_d(out_sync_err_d), .scan_en(bist_out),
|
halcheck: *W,MAXLEN (./main.v,15|0): The HDL source line is 161 characters, which exceeds the recommended length of 80 characters.
     .scan_in(in_x0), .scan_out(scan_out));
|
halcheck: *W,CTLCHR (./main.v,16|0): HDL source line contains one or more control characters.
LFSR LFSR_in (.CLK(CLK), .RST(RST), .x0(in_x0),.x1(in_x1),.x2(in_x2)); //LFSR na entrada do circuito
|
halcheck: *W,CTLCHR (./main.v,17|0): HDL source line contains one or more control characters.
LFSR LFSR_in (.CLK(CLK), .RST(RST), .x0(in_x0),.x1(in_x1),.x2(in_x2)); //LFSR na entrada do circuito
|
halcheck: *W,MAXLEN (./main.v,17|0): The HDL source line is 101 characters, which exceeds the recommended length of 80 characters.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halcheck: *W,CTLCHR (./main.v,18|0): HDL source line contains one or more control characters.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halcheck: *W,MAXLEN (./main.v,18|0): The HDL source line is 208 characters, which exceeds the recommended length of 80 characters.
MISR MISR(.CLK(CLK),.e0(scan_out),.e1(out_synced_d),.e2(out_sync_err_d),.h0(h0),.h1(h1),.h2(h2));
|
halcheck: *W,CTLCHR (./main.v,19|0): HDL source line contains one or more control characters.
MISR MISR(.CLK(CLK),.e0(scan_out),.e1(out_synced_d),.e2(out_sync_err_d),.h0(h0),.h1(h1),.h2(h2));
|
halcheck: *W,MAXLEN (./main.v,19|0): The HDL source line is 98 characters, which exceeds the recommended length of 80 characters.
//Falta signature e comparador
|
halcheck: *W,CTLCHR (./main.v,20|0): HDL source line contains one or more control characters.
always @(*) //Mux da entrada dos dados
|
halcheck: *W,CTLCHR (./main.v,21|0): HDL source line contains one or more control characters.
begin    
|
halcheck: *W,CTLCHR (./main.v,22|0): HDL source line contains one or more control characters.
    if  (bist_out == 0) //entrada comum do circuito
|
halcheck: *W,CTLCHR (./main.v,23|0): HDL source line contains one or more control characters.
    begin
|
halcheck: *W,CTLCHR (./main.v,24|0): HDL source line contains one or more control characters.
        circ_k = in_k;
|
halcheck: *W,CTLCHR (./main.v,25|0): HDL source line contains one or more control characters.
        circ_j = in_j;
|
halcheck: *W,CTLCHR (./main.v,26|0): HDL source line contains one or more control characters.
        circ_en = in_en; 
|
halcheck: *W,CTLCHR (./main.v,27|0): HDL source line contains one or more control characters.
    end    
|
halcheck: *W,CTLCHR (./main.v,28|0): HDL source line contains one or more control characters.
    else    //Vetor teste como entradas
|
halcheck: *W,CTLCHR (./main.v,29|0): HDL source line contains one or more control characters.
    begin
|
halcheck: *W,CTLCHR (./main.v,30|0): HDL source line contains one or more control characters.
        circ_k = in_x0;
|
halcheck: *W,CTLCHR (./main.v,31|0): HDL source line contains one or more control characters.
        circ_j = in_x1;
|
halcheck: *W,CTLCHR (./main.v,32|0): HDL source line contains one or more control characters.
        circ_en = in_x2;
|
halcheck: *W,CTLCHR (./main.v,33|0): HDL source line contains one or more control characters.
    end    
|
halcheck: *W,CTLCHR (./main.v,34|0): HDL source line contains one or more control characters.
end
|
halcheck: *W,CTLCHR (./main.v,35|0): HDL source line contains one or more control characters.

|
halcheck: *W,CTLCHR (./main.v,36|0): HDL source line contains one or more control characters.
//always @(*) //Comparador da saida
|
halcheck: *W,CTLCHR (./main.v,37|0): HDL source line contains one or more control characters.
//begin
|
halcheck: *W,CTLCHR (./main.v,38|0): HDL source line contains one or more control characters.
//    if (h2 & h1 & h0 != s2 & s1 & s0)
|
halcheck: *W,CTLCHR (./main.v,39|0): HDL source line contains one or more control characters.
//        count = count +1;    
|
halcheck: *W,CTLCHR (./main.v,40|0): HDL source line contains one or more control characters.
//    pass_fail = count;    
|
halcheck: *W,CTLCHR (./main.v,41|0): HDL source line contains one or more control characters.
//end    
|
halcheck: *W,CTLCHR (./main.v,42|0): HDL source line contains one or more control characters.
endmodule
|
halcheck: *W,CTLCHR (./main.v,43|0): HDL source line contains one or more control characters.
input CLK,RST,bist_start,in_k,in_j,in_en;
|
halcheck: *N,DECLIN (./main.v,4|0): Use a separate line for each HDL declaration.
output wire bist_end, out_synced_d, out_sync_err_d;
|
halcheck: *N,DECLIN (./main.v,6|0): Use a separate line for each HDL declaration.
input CLK,RST,bist_start,in_k,in_j,in_en;
|
halcheck: *W,LCVARN (./main.v,4|0): Net name 'CLK' uses uppercase characters.
input CLK,RST,bist_start,in_k,in_j,in_en;
|
halcheck: *W,LCVARN (./main.v,4|0): Net name 'RST' uses uppercase characters.
reg [7:0] count; //Conferir contador do pass_fail
|
halcheck: *W,STYVAL (./main.v,12|0): Numeric value '7' used for identifier 'count'. Use constants to avoid portability issues.
begin    
|
halcheck: *W,NOBLKN (./main.v,22|0): Each block should be labeled with a meaningful name.
    if  (bist_out == 0) //entrada comum do circuito
|
halcheck: *W,ULCMPE (./main.v,23|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit main. LHS operand is 1 bits, RHS operand is 32 bits.
module circuito12_scan(clk, rst, k, j, rx_en, synced_d, sync_err_d, scan_en,
|
halcheck: *W,DIFFMN (./circuito_scan_syn.v,8|0): Module name 'circuito12_scan' differs from file name 'circuito_scan_syn.v'.
module circuito12_scan(clk, rst, k, j, rx_en, synced_d, sync_err_d, scan_en,
|
halcheck: *N,PRTCNT (./circuito_scan_syn.v,8|0): Module/Entity 'circuito12_scan' contains '10' ports.
halcheck: (./circuito_scan_syn.v,8): Number of Input ports: 7.
halcheck: (./circuito_scan_syn.v,8): Number of Output ports: 3.
`timescale 1ns / 1ps
|
halcheck: *N,CDNOTE (./circuito_scan_syn.v,1|0): The compiler directive '`timescale' is used in the RTL.
  input clk, rst, k, j, rx_en, scan_en, scan_in;
|
halcheck: *N,DECLIN (./circuito_scan_syn.v,10|0): Use a separate line for each HDL declaration.
  output synced_d, sync_err_d, scan_out;
|
halcheck: *N,DECLIN (./circuito_scan_syn.v,11|0): Use a separate line for each HDL declaration.
  wire [2:0] fs_state;
|
halcheck: *W,STYVAL (./circuito_scan_syn.v,14|0): Numeric value '2' used for identifier 'fs_state'. Use constants to avoid portability issues.
  DFS1 \fs_state_reg[2] (.C (clk), .D (n_19), .SD (n_1), .SE (scan_en),
|
halcheck: *N,IDLENG (./circuito_scan_syn.v,18|0): Identifier name '\fs_state_reg[2] ' is not of appropriate length (4 to 16 characters).
  DFS1 \fs_state_reg[2] (.C (clk), .D (n_19), .SD (n_1), .SE (scan_en),
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,18|0): Module name 'DFS1' uses uppercase characters.
  JKS3 \fs_state_reg[1] (.C (clk), .J (n_17), .K (n_10), .SD (n_0), .SE
|
halcheck: *N,IDLENG (./circuito_scan_syn.v,20|0): Identifier name '\fs_state_reg[1] ' is not of appropriate length (4 to 16 characters).
  JKS3 \fs_state_reg[1] (.C (clk), .J (n_17), .K (n_10), .SD (n_0), .SE
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,20|0): Module name 'JKS3' uses uppercase characters.
  OAI310 g935__2398(.A (n_6), .B (fs_state[0]), .C (fs_state[2]), .D
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,22|0): Module name 'OAI310' uses uppercase characters.
  NAND20 g937__5107(.A (n_14), .B (n_8), .Q (n_20));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,24|0): Module name 'NAND20' uses uppercase characters.
  INV2 g938(.A (n_18), .Q (n_19));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,25|0): Module name 'INV2' uses uppercase characters.
  AOI221 g940__6260(.A (n_12), .B (n_17), .C (fs_state[2]), .D (n_16),
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,26|0): Module name 'AOI221' uses uppercase characters.
  DFS1 \fs_state_reg[0] (.C (clk), .D (n_16), .SD (scan_in), .SE
|
halcheck: *N,IDLENG (./circuito_scan_syn.v,28|0): Identifier name '\fs_state_reg[0] ' is not of appropriate length (4 to 16 characters).
  DFS1 \fs_state_reg[0] (.C (clk), .D (n_16), .SD (scan_in), .SE
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,28|0): Module name 'DFS1' uses uppercase characters.
  NOR30 g939__4319(.A (n_4), .B (fs_state[0]), .C (n_9), .Q (synced_d));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,30|0): Module name 'NOR30' uses uppercase characters.
  INV0 g942(.A (n_13), .Q (n_14));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,31|0): Module name 'INV0' uses uppercase characters.
  AOI220 g943__8428(.A (n_12), .B (n_11), .C (fs_state[1]), .D
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,32|0): Module name 'AOI220' uses uppercase characters.
  NOR21 g944__5526(.A (rst), .B (n_11), .Q (n_17));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,34|0): Module name 'NOR21' uses uppercase characters.
  INV2 g945(.A (n_16), .Q (n_10));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,35|0): Module name 'INV2' uses uppercase characters.
  AOI210 g946__6783(.A (fs_state[1]), .B (k), .C (n_5), .Q (n_9));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,36|0): Module name 'AOI210' uses uppercase characters.
  NOR31 g947__3680(.A (n_7), .B (n_8), .C (rst), .Q (n_16));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,37|0): Module name 'NOR31' uses uppercase characters.
  NAND22 g949__1617(.A (n_7), .B (n_6), .Q (n_11));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,38|0): Module name 'NAND22' uses uppercase characters.
  NOR20 g948__2802(.A (j), .B (n_8), .Q (n_5));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,39|0): Module name 'NOR20' uses uppercase characters.
  IMUX21 g950__1705(.A (n_4), .B (fs_state[2]), .S (fs_state[1]), .Q
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,40|0): Module name 'IMUX21' uses uppercase characters.
  INV0 g951(.A (n_3), .Q (n_6));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,42|0): Module name 'INV0' uses uppercase characters.
  NAND20 g953__5122(.A (k), .B (rx_en), .Q (n_8));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,43|0): Module name 'NAND20' uses uppercase characters.
  NAND20 g952__8246(.A (j), .B (rx_en), .Q (n_3));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,44|0): Module name 'NAND20' uses uppercase characters.
  INV3 g955(.A (fs_state[0]), .Q (n_7));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,45|0): Module name 'INV3' uses uppercase characters.
  INV2 g954(.A (fs_state[2]), .Q (n_4));
|
halcheck: *W,LCVARN (./circuito_scan_syn.v,46|0): Module name 'INV2' uses uppercase characters.
  wire [2:0] fs_state;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,14|0): Wire 'fs_state' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_0' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_1' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_3' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_4' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_5' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_6' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_7' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_0, n_1, n_3, n_4, n_5, n_6, n_7, n_8;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,15|0): Wire 'n_8' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_9' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_10' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_11' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_12' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_13' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_14' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_16' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_9, n_10, n_11, n_12, n_13, n_14, n_16, n_17;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,16|0): Wire 'n_17' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_18, n_19, n_20;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,17|0): Wire 'n_18' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_18, n_19, n_20;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,17|0): Wire 'n_19' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
  wire n_18, n_19, n_20;
|
halcheck: *W,UASWIR (./circuito_scan_syn.v,17|0): Wire 'n_20' defined in module 'circuito12_scan' is unassigned, but drives at least an object.
LFSR LFSR_in (.CLK(CLK), .RST(RST), .x0(in_x0),.x1(in_x1),.x2(in_x2)); //LFSR na entrada do circuito
|
halcheck: *W,LCVARN (./main.v,17|0): Module instance name 'LFSR_in' uses uppercase characters.
module LFSR(CLK,RST,x0,x1,x2);
|
halcheck: *W,LCVARN (./LFSR.v,3|0): Module name 'LFSR' uses uppercase characters.
module LFSR(CLK,RST,x0,x1,x2);
|
halcheck: *N,PRTCNT (./LFSR.v,3|0): Module/Entity 'LFSR' contains '5' ports.
halcheck: (./LFSR.v,3): Number of Input ports: 2.
halcheck: (./LFSR.v,3): Number of Output ports: 3.
`timescale 1ns / 1ps
|
halcheck: *W,CTLCHR (./LFSR.v,1|0): HDL source line contains one or more control characters.
`timescale 1ns / 1ps
|
halcheck: *N,CDNOTE (./LFSR.v,1|0): The compiler directive '`timescale' is used in the RTL.

|
halcheck: *W,CTLCHR (./LFSR.v,2|0): HDL source line contains one or more control characters.
module LFSR(CLK,RST,x0,x1,x2);
|
halcheck: *W,CTLCHR (./LFSR.v,3|0): HDL source line contains one or more control characters.
input CLK,RST;
|
halcheck: *W,CTLCHR (./LFSR.v,4|0): HDL source line contains one or more control characters.

|
halcheck: *W,CTLCHR (./LFSR.v,5|0): HDL source line contains one or more control characters.
output reg x0,x1,x2;
|
halcheck: *W,CTLCHR (./LFSR.v,6|0): HDL source line contains one or more control characters.

|
halcheck: *W,CTLCHR (./LFSR.v,7|0): HDL source line contains one or more control characters.
//Fibonacci  polinomio 1+x^2+x^3
|
halcheck: *W,CTLCHR (./LFSR.v,8|0): HDL source line contains one or more control characters.
always @(posedge CLK)
|
halcheck: *W,CTLCHR (./LFSR.v,9|0): HDL source line contains one or more control characters.
begin
|
halcheck: *W,CTLCHR (./LFSR.v,10|0): HDL source line contains one or more control characters.
    if (RST == 0)
|
halcheck: *W,CTLCHR (./LFSR.v,11|0): HDL source line contains one or more control characters.
    begin
|
halcheck: *W,CTLCHR (./LFSR.v,12|0): HDL source line contains one or more control characters.
        x1 <= x2;
|
halcheck: *W,CTLCHR (./LFSR.v,13|0): HDL source line contains one or more control characters.
        x2 <= (x2 ^ x0);  
|
halcheck: *W,CTLCHR (./LFSR.v,14|0): HDL source line contains one or more control characters.
        x0 <= x1;
|
halcheck: *W,CTLCHR (./LFSR.v,15|0): HDL source line contains one or more control characters.
    end 
|
halcheck: *W,CTLCHR (./LFSR.v,16|0): HDL source line contains one or more control characters.
    else
|
halcheck: *W,CTLCHR (./LFSR.v,17|0): HDL source line contains one or more control characters.
    begin
|
halcheck: *W,CTLCHR (./LFSR.v,18|0): HDL source line contains one or more control characters.
        x0 <= 1;
|
halcheck: *W,CTLCHR (./LFSR.v,19|0): HDL source line contains one or more control characters.
        x1 <= 1;
|
halcheck: *W,CTLCHR (./LFSR.v,20|0): HDL source line contains one or more control characters.
        x2 <= 1;
|
halcheck: *W,CTLCHR (./LFSR.v,21|0): HDL source line contains one or more control characters.
    end
|
halcheck: *W,CTLCHR (./LFSR.v,22|0): HDL source line contains one or more control characters.
end
|
halcheck: *W,CTLCHR (./LFSR.v,23|0): HDL source line contains one or more control characters.
endmodule
|
halcheck: *W,CTLCHR (./LFSR.v,24|0): HDL source line contains one or more control characters.
input CLK,RST;
|
halcheck: *N,DECLIN (./LFSR.v,4|0): Use a separate line for each HDL declaration.
output reg x0,x1,x2;
|
halcheck: *N,DECLIN (./LFSR.v,6|0): Use a separate line for each HDL declaration.
input CLK,RST;
|
halcheck: *W,LCVARN (./LFSR.v,4|0): Net name 'CLK' uses uppercase characters.
input CLK,RST;
|
halcheck: *W,LCVARN (./LFSR.v,4|0): Net name 'RST' uses uppercase characters.
begin
|
halcheck: *W,NOBLKN (./LFSR.v,10|0): Each block should be labeled with a meaningful name.
    if (RST == 0)
|
halcheck: *W,ULCMPE (./LFSR.v,11|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit LFSR_in. LHS operand is 1 bits, RHS operand is 32 bits.
        x0 <= 1;
|
halcheck: *W,IMPDTC (./LFSR.v,19|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit LFSR_in.
        x0 <= 1;
|
halcheck: *W,INTTOB (./LFSR.v,19|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit LFSR_in.
        x0 <= 1;
|
halcheck: *W,TRUNCZ (./LFSR.v,19|0): Truncation in constant conversion without a loss of bits in module/design-unit LFSR_in.
        x1 <= 1;
|
halcheck: *W,IMPDTC (./LFSR.v,20|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit LFSR_in.
        x1 <= 1;
|
halcheck: *W,INTTOB (./LFSR.v,20|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit LFSR_in.
        x1 <= 1;
|
halcheck: *W,TRUNCZ (./LFSR.v,20|0): Truncation in constant conversion without a loss of bits in module/design-unit LFSR_in.
        x2 <= 1;
|
halcheck: *W,IMPDTC (./LFSR.v,21|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit LFSR_in.
        x2 <= 1;
|
halcheck: *W,INTTOB (./LFSR.v,21|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit LFSR_in.
        x2 <= 1;
|
halcheck: *W,TRUNCZ (./LFSR.v,21|0): Truncation in constant conversion without a loss of bits in module/design-unit LFSR_in.
    if (RST == 0)
|
halcheck: *N,ALOWID (./LFSR.v,11|0): Signal/variable name 'RST' does not follow the active-low naming convention : should end with '_n'.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halcheck: *W,LCVARN (./main.v,18|0): Module instance name 'Bist' uses uppercase characters.
module Bist_control(CLK, RESET, START, OUT, BIST_END, RUNNING,INIT,FINISH);
|
halcheck: *W,LCVARN (./Bist_Control.v,3|0): Module name 'Bist_control' uses uppercase characters.
module Bist_control(CLK, RESET, START, OUT, BIST_END, RUNNING,INIT,FINISH);
|
halcheck: *W,DIFFMN (./Bist_Control.v,3|0): Module name 'Bist_control' differs from file name 'Bist_Control.v'.
module Bist_control(CLK, RESET, START, OUT, BIST_END, RUNNING,INIT,FINISH);
|
halcheck: *N,PRTCNT (./Bist_Control.v,3|0): Module/Entity 'Bist_control' contains '8' ports.
halcheck: (./Bist_Control.v,3): Number of Input ports: 3.
halcheck: (./Bist_Control.v,3): Number of Output ports: 5.
`timescale 1ns / 100ps
|
halcheck: *W,CTLCHR (./Bist_Control.v,1|0): HDL source line contains one or more control characters.
`timescale 1ns / 100ps
|
halcheck: *N,CDNOTE (./Bist_Control.v,1|0): The compiler directive '`timescale' is used in the RTL.

|
halcheck: *W,CTLCHR (./Bist_Control.v,2|0): HDL source line contains one or more control characters.
module Bist_control(CLK, RESET, START, OUT, BIST_END, RUNNING,INIT,FINISH);
|
halcheck: *W,CTLCHR (./Bist_Control.v,3|0): HDL source line contains one or more control characters.
   input CLK,RESET,START;
|
halcheck: *W,CTLCHR (./Bist_Control.v,4|0): HDL source line contains one or more control characters.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *W,CTLCHR (./Bist_Control.v,5|0): HDL source line contains one or more control characters.
   // bom adicionar 2 sinais, um antes do running e outro antes do bist_end (Init e fisish)
|
halcheck: *W,CTLCHR (./Bist_Control.v,6|0): HDL source line contains one or more control characters.
   // bom adicionar 2 sinais, um antes do running e outro antes do bist_end (Init e fisish)
|
halcheck: *W,MAXLEN (./Bist_Control.v,6|0): The HDL source line is 93 characters, which exceeds the recommended length of 80 characters.
   reg [7:0] count; //deve contar ate 89 = (N+1)*(M+1)-1 = (9+1)*(8+1) 
|
halcheck: *W,CTLCHR (./Bist_Control.v,7|0): HDL source line contains one or more control characters.
   reg [3:0] count_N, count_M;
|
halcheck: *W,CTLCHR (./Bist_Control.v,8|0): HDL source line contains one or more control characters.
   
|
halcheck: *W,CTLCHR (./Bist_Control.v,9|0): HDL source line contains one or more control characters.
   // state flip-flops;
|
halcheck: *W,CTLCHR (./Bist_Control.v,10|0): HDL source line contains one or more control characters.
   reg [2:0] state, next_state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,11|0): HDL source line contains one or more control characters.
 
|
halcheck: *W,CTLCHR (./Bist_Control.v,12|0): HDL source line contains one or more control characters.
   // state coding
|
halcheck: *W,CTLCHR (./Bist_Control.v,13|0): HDL source line contains one or more control characters.
   localparam [2:0] IDLE=0, S0=1, S1=2, S2=3, S3=4, S4=5,S5=6;
|
halcheck: *W,CTLCHR (./Bist_Control.v,14|0): HDL source line contains one or more control characters.
   localparam [4:0] N=9, M=9;
|
halcheck: *W,CTLCHR (./Bist_Control.v,15|0): HDL source line contains one or more control characters.
    
|
halcheck: *W,CTLCHR (./Bist_Control.v,16|0): HDL source line contains one or more control characters.

|
halcheck: *W,CTLCHR (./Bist_Control.v,17|0): HDL source line contains one or more control characters.
    always @(posedge CLK or posedge RESET)
|
halcheck: *W,CTLCHR (./Bist_Control.v,18|0): HDL source line contains one or more control characters.
       begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,19|0): HDL source line contains one or more control characters.
           if (RESET == 1'b1)
|
halcheck: *W,CTLCHR (./Bist_Control.v,20|0): HDL source line contains one or more control characters.
            begin    
|
halcheck: *W,CTLCHR (./Bist_Control.v,21|0): HDL source line contains one or more control characters.
              state <= IDLE;  
|
halcheck: *W,CTLCHR (./Bist_Control.v,22|0): HDL source line contains one or more control characters.
              count_N <=0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,23|0): HDL source line contains one or more control characters.
              count_M <=0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,24|0): HDL source line contains one or more control characters.
            end
|
halcheck: *W,CTLCHR (./Bist_Control.v,25|0): HDL source line contains one or more control characters.
            else begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,26|0): HDL source line contains one or more control characters.
               state <= next_state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,27|0): HDL source line contains one or more control characters.
               if(count_M==M)
|
halcheck: *W,CTLCHR (./Bist_Control.v,28|0): HDL source line contains one or more control characters.
               begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,29|0): HDL source line contains one or more control characters.
                    count_M <= 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,30|0): HDL source line contains one or more control characters.
                    count_N <= 0;   
|
halcheck: *W,CTLCHR (./Bist_Control.v,31|0): HDL source line contains one or more control characters.
               end               
|
halcheck: *W,CTLCHR (./Bist_Control.v,32|0): HDL source line contains one or more control characters.
               else if(count_N==N)
|
halcheck: *W,CTLCHR (./Bist_Control.v,33|0): HDL source line contains one or more control characters.
               begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,34|0): HDL source line contains one or more control characters.
                        count_M <= count_M + 8'd1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,35|0): HDL source line contains one or more control characters.
                        count_N <= 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,36|0): HDL source line contains one or more control characters.
               end
|
halcheck: *W,CTLCHR (./Bist_Control.v,37|0): HDL source line contains one or more control characters.
               
|
halcheck: *W,CTLCHR (./Bist_Control.v,38|0): HDL source line contains one or more control characters.
               else if(RUNNING == 1'b1)
|
halcheck: *W,CTLCHR (./Bist_Control.v,39|0): HDL source line contains one or more control characters.
               begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,40|0): HDL source line contains one or more control characters.
                        count_N <= count_N + 8'd1;  
|
halcheck: *W,CTLCHR (./Bist_Control.v,41|0): HDL source line contains one or more control characters.
               end
|
halcheck: *W,CTLCHR (./Bist_Control.v,42|0): HDL source line contains one or more control characters.
            end  
|
halcheck: *W,CTLCHR (./Bist_Control.v,43|0): HDL source line contains one or more control characters.
    end
|
halcheck: *W,CTLCHR (./Bist_Control.v,44|0): HDL source line contains one or more control characters.
    always @(*)
|
halcheck: *W,CTLCHR (./Bist_Control.v,45|0): HDL source line contains one or more control characters.
    begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,46|0): HDL source line contains one or more control characters.
        case (state)
|
halcheck: *W,CTLCHR (./Bist_Control.v,47|0): HDL source line contains one or more control characters.
        IDLE:begin  //posicao inicial, para garantir start=0
|
halcheck: *W,CTLCHR (./Bist_Control.v,48|0): HDL source line contains one or more control characters.
            if (START == 0)
|
halcheck: *W,CTLCHR (./Bist_Control.v,49|0): HDL source line contains one or more control characters.
             next_state = S0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,50|0): HDL source line contains one or more control characters.
            else
|
halcheck: *W,CTLCHR (./Bist_Control.v,51|0): HDL source line contains one or more control characters.
                next_state = state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,52|0): HDL source line contains one or more control characters.
                
|
halcheck: *W,CTLCHR (./Bist_Control.v,53|0): HDL source line contains one or more control characters.
            RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,54|0): HDL source line contains one or more control characters.
            BIST_END = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,55|0): HDL source line contains one or more control characters.
            OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,56|0): HDL source line contains one or more control characters.
            INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,57|0): HDL source line contains one or more control characters.
            FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,58|0): HDL source line contains one or more control characters.
            end
|
halcheck: *W,CTLCHR (./Bist_Control.v,59|0): HDL source line contains one or more control characters.
        S0:begin    // Garantido start=0 espera para start=1
|
halcheck: *W,CTLCHR (./Bist_Control.v,60|0): HDL source line contains one or more control characters.
                if (START == 1)
|
halcheck: *W,CTLCHR (./Bist_Control.v,61|0): HDL source line contains one or more control characters.
                    next_state = S1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,62|0): HDL source line contains one or more control characters.
              else
|
halcheck: *W,CTLCHR (./Bist_Control.v,63|0): HDL source line contains one or more control characters.
                   next_state = state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,64|0): HDL source line contains one or more control characters.
 
|
halcheck: *W,CTLCHR (./Bist_Control.v,65|0): HDL source line contains one or more control characters.
               RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,66|0): HDL source line contains one or more control characters.
               BIST_END = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,67|0): HDL source line contains one or more control characters.
               OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,68|0): HDL source line contains one or more control characters.
               INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,69|0): HDL source line contains one or more control characters.
               FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,70|0): HDL source line contains one or more control characters.
            end    
|
halcheck: *W,CTLCHR (./Bist_Control.v,71|0): HDL source line contains one or more control characters.
        S1:begin    //Ativa sinal de init antes de comecar a contagem
|
halcheck: *W,CTLCHR (./Bist_Control.v,72|0): HDL source line contains one or more control characters.
               next_state = S2;
|
halcheck: *W,CTLCHR (./Bist_Control.v,73|0): HDL source line contains one or more control characters.
               RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,74|0): HDL source line contains one or more control characters.
               BIST_END = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,75|0): HDL source line contains one or more control characters.
               OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,76|0): HDL source line contains one or more control characters.
               INIT = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,77|0): HDL source line contains one or more control characters.
               FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,78|0): HDL source line contains one or more control characters.
            end
|
halcheck: *W,CTLCHR (./Bist_Control.v,79|0): HDL source line contains one or more control characters.
        S2:if (count_N==N) //funcionamento do contador
|
halcheck: *W,CTLCHR (./Bist_Control.v,80|0): HDL source line contains one or more control characters.
            begin 
|
halcheck: *W,CTLCHR (./Bist_Control.v,81|0): HDL source line contains one or more control characters.
                next_state = state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,82|0): HDL source line contains one or more control characters.
                RUNNING = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,83|0): HDL source line contains one or more control characters.
                BIST_END = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,84|0): HDL source line contains one or more control characters.
                OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,85|0): HDL source line contains one or more control characters.
                INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,86|0): HDL source line contains one or more control characters.
                FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,87|0): HDL source line contains one or more control characters.
            end
|
halcheck: *W,CTLCHR (./Bist_Control.v,88|0): HDL source line contains one or more control characters.
            else if (count_M==M)
|
halcheck: *W,CTLCHR (./Bist_Control.v,89|0): HDL source line contains one or more control characters.
            begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,90|0): HDL source line contains one or more control characters.
                next_state = S3;
|
halcheck: *W,CTLCHR (./Bist_Control.v,91|0): HDL source line contains one or more control characters.
                RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,92|0): HDL source line contains one or more control characters.
                BIST_END = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,93|0): HDL source line contains one or more control characters.
                OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,94|0): HDL source line contains one or more control characters.
                INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,95|0): HDL source line contains one or more control characters.
                FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,96|0): HDL source line contains one or more control characters.
            end
|
halcheck: *W,CTLCHR (./Bist_Control.v,97|0): HDL source line contains one or more control characters.
            else 
|
halcheck: *W,CTLCHR (./Bist_Control.v,98|0): HDL source line contains one or more control characters.
            begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,99|0): HDL source line contains one or more control characters.
                 next_state = state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,100|0): HDL source line contains one or more control characters.
                 RUNNING = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,101|0): HDL source line contains one or more control characters.
                 BIST_END = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,102|0): HDL source line contains one or more control characters.
                 OUT = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,103|0): HDL source line contains one or more control characters.
                 INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,104|0): HDL source line contains one or more control characters.
                 FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,105|0): HDL source line contains one or more control characters.
            end
|
halcheck: *W,CTLCHR (./Bist_Control.v,106|0): HDL source line contains one or more control characters.
        S3:begin //Sinal de finish
|
halcheck: *W,CTLCHR (./Bist_Control.v,107|0): HDL source line contains one or more control characters.
               next_state = S4;
|
halcheck: *W,CTLCHR (./Bist_Control.v,108|0): HDL source line contains one or more control characters.
               RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,109|0): HDL source line contains one or more control characters.
               BIST_END = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,110|0): HDL source line contains one or more control characters.
               OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,111|0): HDL source line contains one or more control characters.
               INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,112|0): HDL source line contains one or more control characters.
               FINISH = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,113|0): HDL source line contains one or more control characters.
            end     
|
halcheck: *W,CTLCHR (./Bist_Control.v,114|0): HDL source line contains one or more control characters.
        S4:begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,115|0): HDL source line contains one or more control characters.
        if (START == 0) //Espera zerar o start enquanto mantem o bist alto
|
halcheck: *W,CTLCHR (./Bist_Control.v,116|0): HDL source line contains one or more control characters.
            next_state = S5; 
|
halcheck: *W,CTLCHR (./Bist_Control.v,117|0): HDL source line contains one or more control characters.
        else   
|
halcheck: *W,CTLCHR (./Bist_Control.v,118|0): HDL source line contains one or more control characters.
            next_state = state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,119|0): HDL source line contains one or more control characters.
            
|
halcheck: *W,CTLCHR (./Bist_Control.v,120|0): HDL source line contains one or more control characters.
        RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,121|0): HDL source line contains one or more control characters.
        OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,122|0): HDL source line contains one or more control characters.
        BIST_END = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,123|0): HDL source line contains one or more control characters.
        INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,124|0): HDL source line contains one or more control characters.
        FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,125|0): HDL source line contains one or more control characters.
              
|
halcheck: *W,CTLCHR (./Bist_Control.v,126|0): HDL source line contains one or more control characters.
         end
|
halcheck: *W,CTLCHR (./Bist_Control.v,127|0): HDL source line contains one or more control characters.
         S5:begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,128|0): HDL source line contains one or more control characters.
        if (START == 1) //verifica borda de subida do start antes de recomecar
|
halcheck: *W,CTLCHR (./Bist_Control.v,129|0): HDL source line contains one or more control characters.
            next_state = S1; 
|
halcheck: *W,CTLCHR (./Bist_Control.v,130|0): HDL source line contains one or more control characters.
        else   
|
halcheck: *W,CTLCHR (./Bist_Control.v,131|0): HDL source line contains one or more control characters.
            next_state = state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,132|0): HDL source line contains one or more control characters.

|
halcheck: *W,CTLCHR (./Bist_Control.v,133|0): HDL source line contains one or more control characters.
        RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,134|0): HDL source line contains one or more control characters.
        OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,135|0): HDL source line contains one or more control characters.
        BIST_END = 1;
|
halcheck: *W,CTLCHR (./Bist_Control.v,136|0): HDL source line contains one or more control characters.
        INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,137|0): HDL source line contains one or more control characters.
        FINISH = 0;    
|
halcheck: *W,CTLCHR (./Bist_Control.v,138|0): HDL source line contains one or more control characters.
        end
|
halcheck: *W,CTLCHR (./Bist_Control.v,139|0): HDL source line contains one or more control characters.
        default:   
|
halcheck: *W,CTLCHR (./Bist_Control.v,140|0): HDL source line contains one or more control characters.
         begin
|
halcheck: *W,CTLCHR (./Bist_Control.v,141|0): HDL source line contains one or more control characters.
             next_state = state;
|
halcheck: *W,CTLCHR (./Bist_Control.v,142|0): HDL source line contains one or more control characters.
             RUNNING = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,143|0): HDL source line contains one or more control characters.
             OUT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,144|0): HDL source line contains one or more control characters.
             BIST_END = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,145|0): HDL source line contains one or more control characters.
             INIT = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,146|0): HDL source line contains one or more control characters.
             FINISH = 0;
|
halcheck: *W,CTLCHR (./Bist_Control.v,147|0): HDL source line contains one or more control characters.
         end 
|
halcheck: *W,CTLCHR (./Bist_Control.v,148|0): HDL source line contains one or more control characters.
            
|
halcheck: *W,CTLCHR (./Bist_Control.v,149|0): HDL source line contains one or more control characters.
        endcase
|
halcheck: *W,CTLCHR (./Bist_Control.v,150|0): HDL source line contains one or more control characters.
    end
|
halcheck: *W,CTLCHR (./Bist_Control.v,151|0): HDL source line contains one or more control characters.

|
halcheck: *W,CTLCHR (./Bist_Control.v,152|0): HDL source line contains one or more control characters.
   input CLK,RESET,START;
|
halcheck: *N,DECLIN (./Bist_Control.v,4|0): Use a separate line for each HDL declaration.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *W,KEYWOD (./Bist_Control.v,5|0): VHDL reserved word 'OUT' used as an identifier or label.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *N,DECLIN (./Bist_Control.v,5|0): Use a separate line for each HDL declaration.
   input CLK,RESET,START;
|
halcheck: *W,LCVARN (./Bist_Control.v,4|0): Net name 'CLK' uses uppercase characters.
   input CLK,RESET,START;
|
halcheck: *W,LCVARN (./Bist_Control.v,4|0): Net name 'RESET' uses uppercase characters.
   input CLK,RESET,START;
|
halcheck: *W,LCVARN (./Bist_Control.v,4|0): Net name 'START' uses uppercase characters.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *W,LCVARN (./Bist_Control.v,5|0): Register name 'OUT' uses uppercase characters.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *W,LCVARN (./Bist_Control.v,5|0): Register name 'BIST_END' uses uppercase characters.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *W,LCVARN (./Bist_Control.v,5|0): Register name 'RUNNING' uses uppercase characters.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *W,LCVARN (./Bist_Control.v,5|0): Register name 'INIT' uses uppercase characters.
   output reg OUT,BIST_END,RUNNING,INIT,FINISH;
|
halcheck: *W,LCVARN (./Bist_Control.v,5|0): Register name 'FINISH' uses uppercase characters.
   reg [7:0] count; //deve contar ate 89 = (N+1)*(M+1)-1 = (9+1)*(8+1) 
|
halcheck: *W,STYVAL (./Bist_Control.v,7|0): Numeric value '7' used for identifier 'count'. Use constants to avoid portability issues.
   reg [3:0] count_N, count_M;
|
halcheck: *W,LCVARN (./Bist_Control.v,8|0): Register name 'count_N' uses uppercase characters.
   reg [3:0] count_N, count_M;
|
halcheck: *W,STYVAL (./Bist_Control.v,8|0): Numeric value '3' used for identifier 'count_N'. Use constants to avoid portability issues.
   reg [3:0] count_N, count_M;
|
halcheck: *W,LCVARN (./Bist_Control.v,8|0): Register name 'count_M' uses uppercase characters.
   localparam [2:0] IDLE=0, S0=1, S1=2, S2=3, S3=4, S4=5,S5=6;
|
halcheck: *N,IDLENG (./Bist_Control.v,14|0): Identifier name 'S0' is not of appropriate length (4 to 16 characters).
   localparam [2:0] IDLE=0, S0=1, S1=2, S2=3, S3=4, S4=5,S5=6;
|
halcheck: *N,IDLENG (./Bist_Control.v,14|0): Identifier name 'S1' is not of appropriate length (4 to 16 characters).
   localparam [2:0] IDLE=0, S0=1, S1=2, S2=3, S3=4, S4=5,S5=6;
|
halcheck: *N,IDLENG (./Bist_Control.v,14|0): Identifier name 'S2' is not of appropriate length (4 to 16 characters).
   localparam [2:0] IDLE=0, S0=1, S1=2, S2=3, S3=4, S4=5,S5=6;
|
halcheck: *N,IDLENG (./Bist_Control.v,14|0): Identifier name 'S3' is not of appropriate length (4 to 16 characters).
   localparam [2:0] IDLE=0, S0=1, S1=2, S2=3, S3=4, S4=5,S5=6;
|
halcheck: *N,IDLENG (./Bist_Control.v,14|0): Identifier name 'S4' is not of appropriate length (4 to 16 characters).
   localparam [2:0] IDLE=0, S0=1, S1=2, S2=3, S3=4, S4=5,S5=6;
|
halcheck: *N,IDLENG (./Bist_Control.v,14|0): Identifier name 'S5' is not of appropriate length (4 to 16 characters).
   localparam [4:0] N=9, M=9;
|
halcheck: *N,IDLENG (./Bist_Control.v,15|0): Identifier name 'N' is not of appropriate length (4 to 16 characters).
   localparam [4:0] N=9, M=9;
|
halcheck: *N,IDLENG (./Bist_Control.v,15|0): Identifier name 'M' is not of appropriate length (4 to 16 characters).
       begin
|
halcheck: *W,NOBLKN (./Bist_Control.v,19|0): Each block should be labeled with a meaningful name.
              state <= IDLE;  
|
halcheck: *W,TRUNCZ (./Bist_Control.v,22|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
              count_N <=0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,23|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
              count_N <=0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,23|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
              count_M <=0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,24|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
              count_M <=0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,24|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               if(count_M==M)
|
halcheck: *W,ULCMPE (./Bist_Control.v,28|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 4 bits, RHS operand is 5 bits.
                    count_M <= 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,30|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                    count_M <= 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,30|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                    count_N <= 0;   
|
halcheck: *W,IMPDTC (./Bist_Control.v,31|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                    count_N <= 0;   
|
halcheck: *W,TRUNCZ (./Bist_Control.v,31|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               else if(count_N==N)
|
halcheck: *W,ULCMPE (./Bist_Control.v,33|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 4 bits, RHS operand is 5 bits.
                        count_M <= count_M + 8'd1;
|
halcheck: *W,POIASG (./Bist_Control.v,35|0): The result of addition operation may lead to a potential overflow in module/design-unit Bist.
halcheck: (./Bist_Control.v,35): LHS operand 'count_M' is 4 bit(s), RHS operand 'count_M + 8'd1' is 8 bit(s).
halcheck: (./Bist_Control.v,35): Increase the size of LHS by 4 bit(s).
                        count_M <= count_M + 8'd1;
|
halcheck: *W,UELOPR (./Bist_Control.v,35|0): Unequal length operand in bit/arithmetic operator PLUS in module/design-unit Bist.
halcheck: (./Bist_Control.v,35): LHS operand 'count_M' is 4 bits, RHS operand '8'd1' is 8 bits.
                        count_N <= 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,36|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                        count_N <= 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,36|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               else if(RUNNING == 1'b1)
|
halcheck: *W,REVROP (./Bist_Control.v,39|0): Register 'RUNNING' is being read/assigned outside the process in which it was assigned using a blocking assignment.
halcheck: (./Bist_Control.v,45): Assigned using blocking assignment in this process.
                        count_N <= count_N + 8'd1;  
|
halcheck: *W,POIASG (./Bist_Control.v,41|0): The result of addition operation may lead to a potential overflow in module/design-unit Bist.
halcheck: (./Bist_Control.v,41): LHS operand 'count_N' is 4 bit(s), RHS operand 'count_N + 8'd1' is 8 bit(s).
halcheck: (./Bist_Control.v,41): Increase the size of LHS by 4 bit(s).
                        count_N <= count_N + 8'd1;  
|
halcheck: *W,UELOPR (./Bist_Control.v,41|0): Unequal length operand in bit/arithmetic operator PLUS in module/design-unit Bist.
halcheck: (./Bist_Control.v,41): LHS operand 'count_N' is 4 bits, RHS operand '8'd1' is 8 bits.
    begin
|
halcheck: *W,NOBLKN (./Bist_Control.v,46|0): Each block should be labeled with a meaningful name.
            if (START == 0)
|
halcheck: *W,NBGEND (./Bist_Control.v,49|0): Missing begin/end statement in the 'if' block.
            if (START == 0)
|
halcheck: *W,ULCMPE (./Bist_Control.v,49|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 1 bits, RHS operand is 32 bits.
             next_state = S0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,50|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
            RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,54|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
            RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,54|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
            RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,54|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
            BIST_END = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,55|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
            BIST_END = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,55|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
            BIST_END = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,55|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
            OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,56|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
            OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,56|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
            OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,56|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
            INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,57|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
            INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,57|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
            INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,57|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
            FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,58|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
            FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,58|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
            FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,58|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                if (START == 1)
|
halcheck: *W,NBGEND (./Bist_Control.v,61|0): Missing begin/end statement in the 'if' block.
                if (START == 1)
|
halcheck: *W,ULCMPE (./Bist_Control.v,61|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 1 bits, RHS operand is 32 bits.
                    next_state = S1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,62|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,66|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,66|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,66|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,67|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,67|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,67|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,68|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,68|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,68|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,69|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,69|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,69|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,70|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,70|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,70|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               next_state = S2;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,73|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,74|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,74|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,74|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,75|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,75|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,75|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,76|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,76|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,76|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               INIT = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,77|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               INIT = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,77|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               INIT = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,77|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,78|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,78|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,78|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        S2:if (count_N==N) //funcionamento do contador
|
halcheck: *W,ULCMPE (./Bist_Control.v,80|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 4 bits, RHS operand is 5 bits.
                RUNNING = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,83|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                RUNNING = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,83|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                RUNNING = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,83|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                BIST_END = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,84|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                BIST_END = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,84|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                BIST_END = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,84|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,85|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,85|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,85|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,86|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,86|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,86|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,87|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,87|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,87|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
            else if (count_M==M)
|
halcheck: *W,ULCMPE (./Bist_Control.v,89|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 4 bits, RHS operand is 5 bits.
                next_state = S3;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,91|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,92|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,92|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,92|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                BIST_END = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,93|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                BIST_END = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,93|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                BIST_END = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,93|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,94|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,94|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,94|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,95|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,95|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,95|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,96|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,96|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,96|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                 RUNNING = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,101|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                 RUNNING = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,101|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                 RUNNING = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,101|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                 BIST_END = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,102|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                 BIST_END = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,102|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                 BIST_END = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,102|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                 OUT = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,103|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                 OUT = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,103|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                 OUT = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,103|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                 INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,104|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                 INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,104|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                 INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,104|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
                 FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,105|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
                 FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,105|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
                 FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,105|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               next_state = S4;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,108|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,109|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,109|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,109|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,110|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,110|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               BIST_END = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,110|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,111|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,111|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,111|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,112|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,112|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,112|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
               FINISH = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,113|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
               FINISH = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,113|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
               FINISH = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,113|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        if (START == 0) //Espera zerar o start enquanto mantem o bist alto
|
halcheck: *W,NBGEND (./Bist_Control.v,116|0): Missing begin/end statement in the 'if' block.
        if (START == 0) //Espera zerar o start enquanto mantem o bist alto
|
halcheck: *W,ULCMPE (./Bist_Control.v,116|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 1 bits, RHS operand is 32 bits.
            next_state = S5; 
|
halcheck: *W,TRUNCZ (./Bist_Control.v,117|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,121|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,121|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,121|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,122|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,122|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,122|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        BIST_END = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,123|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        BIST_END = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,123|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        BIST_END = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,123|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,124|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,124|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,124|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,125|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,125|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,125|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        if (START == 1) //verifica borda de subida do start antes de recomecar
|
halcheck: *W,NBGEND (./Bist_Control.v,129|0): Missing begin/end statement in the 'if' block.
        if (START == 1) //verifica borda de subida do start antes de recomecar
|
halcheck: *W,ULCMPE (./Bist_Control.v,129|0): Unequal length operands in equality operator encountered (padding produces incorrect result) in module/design-unit Bist. LHS operand is 1 bits, RHS operand is 32 bits.
            next_state = S1; 
|
halcheck: *W,TRUNCZ (./Bist_Control.v,130|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,134|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,134|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,134|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,135|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,135|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,135|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        BIST_END = 1;
|
halcheck: *W,IMPDTC (./Bist_Control.v,136|0): Expression '1' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        BIST_END = 1;
|
halcheck: *W,INTTOB (./Bist_Control.v,136|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        BIST_END = 1;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,136|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,137|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,137|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,137|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
        FINISH = 0;    
|
halcheck: *W,IMPDTC (./Bist_Control.v,138|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
        FINISH = 0;    
|
halcheck: *W,INTTOB (./Bist_Control.v,138|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
        FINISH = 0;    
|
halcheck: *W,TRUNCZ (./Bist_Control.v,138|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
             RUNNING = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,143|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
             RUNNING = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,143|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
             RUNNING = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,143|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
             OUT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,144|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
             OUT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,144|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
             OUT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,144|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
             BIST_END = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,145|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
             BIST_END = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,145|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
             BIST_END = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,145|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
             INIT = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,146|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
             INIT = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,146|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
             INIT = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,146|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
             FINISH = 0;
|
halcheck: *W,IMPDTC (./Bist_Control.v,147|0): Expression '0' implicitly converted to type 'unsigned' from type 'signed' in module/design-unit Bist.
             FINISH = 0;
|
halcheck: *W,INTTOB (./Bist_Control.v,147|0): Assigning a 0 or 1 (32 bits) to a single-bit variable in module/design-unit Bist.
             FINISH = 0;
|
halcheck: *W,TRUNCZ (./Bist_Control.v,147|0): Truncation in constant conversion without a loss of bits in module/design-unit Bist.
   reg [7:0] count; //deve contar ate 89 = (N+1)*(M+1)-1 = (9+1)*(8+1) 
|
halcheck: *W,URAREG (./Bist_Control.v,7|0): Local register variable 'count' defined in module 'Bist_control' is unused (neither read nor assigned).
MISR MISR(.CLK(CLK),.e0(scan_out),.e1(out_synced_d),.e2(out_sync_err_d),.h0(h0),.h1(h1),.h2(h2));
|
halcheck: *W,LCVARN (./main.v,19|0): Module instance name 'MISR' uses uppercase characters.
module MISR(CLK,e0,e1,e2,h0,h1,h2);
|
halcheck: *W,LCVARN (./MISR.v,3|0): Module name 'MISR' uses uppercase characters.
module MISR(CLK,e0,e1,e2,h0,h1,h2);
|
halcheck: *N,PRTCNT (./MISR.v,3|0): Module/Entity 'MISR' contains '7' ports.
halcheck: (./MISR.v,3): Number of Input ports: 4.
halcheck: (./MISR.v,3): Number of Output ports: 3.
`timescale 1ns / 1ps
|
halcheck: *W,CTLCHR (./MISR.v,1|0): HDL source line contains one or more control characters.
`timescale 1ns / 1ps
|
halcheck: *N,CDNOTE (./MISR.v,1|0): The compiler directive '`timescale' is used in the RTL.

|
halcheck: *W,CTLCHR (./MISR.v,2|0): HDL source line contains one or more control characters.
module MISR(CLK,e0,e1,e2,h0,h1,h2);
|
halcheck: *W,CTLCHR (./MISR.v,3|0): HDL source line contains one or more control characters.
input CLK,e0,e1,e2;
|
halcheck: *W,CTLCHR (./MISR.v,4|0): HDL source line contains one or more control characters.
output reg h0,h1,h2;
|
halcheck: *W,CTLCHR (./MISR.v,5|0): HDL source line contains one or more control characters.

|
halcheck: *W,CTLCHR (./MISR.v,6|0): HDL source line contains one or more control characters.
always @(posedge CLK)
|
halcheck: *W,CTLCHR (./MISR.v,7|0): HDL source line contains one or more control characters.
begin
|
halcheck: *W,CTLCHR (./MISR.v,8|0): HDL source line contains one or more control characters.
    h0 <= !(e2 || h1);
|
halcheck: *W,CTLCHR (./MISR.v,9|0): HDL source line contains one or more control characters.
    h1 <= !(e1 || h0);
|
halcheck: *W,CTLCHR (./MISR.v,10|0): HDL source line contains one or more control characters.
    h2 <= !(e0 || !(h2 || !(h1||h0))); 
|
halcheck: *W,CTLCHR (./MISR.v,11|0): HDL source line contains one or more control characters.
end
|
halcheck: *W,CTLCHR (./MISR.v,12|0): HDL source line contains one or more control characters.
endmodule
|
halcheck: *W,CTLCHR (./MISR.v,13|0): HDL source line contains one or more control characters.
input CLK,e0,e1,e2;
|
halcheck: *N,DECLIN (./MISR.v,4|0): Use a separate line for each HDL declaration.
output reg h0,h1,h2;
|
halcheck: *N,DECLIN (./MISR.v,5|0): Use a separate line for each HDL declaration.
input CLK,e0,e1,e2;
|
halcheck: *W,LCVARN (./MISR.v,4|0): Net name 'CLK' uses uppercase characters.
begin
|
halcheck: *W,NOBLKN (./MISR.v,8|0): Each block should be labeled with a meaningful name.
wire h0,h1,h2; //registros misr
|
halcheck: *W,URDWIR (./main.v,11|0): Wire 'h0' defined in module 'main' does not drive any object, but is assigned at least once.
wire h0,h1,h2; //registros misr
|
halcheck: *W,URDWIR (./main.v,11|0): Wire 'h1' defined in module 'main' does not drive any object, but is assigned at least once.
wire h0,h1,h2; //registros misr
|
halcheck: *W,URDWIR (./main.v,11|0): Wire 'h2' defined in module 'main' does not drive any object, but is assigned at least once.
wire s2,s1,s0; //Registros do signature
|
halcheck: *W,URAWIR (./main.v,13|0): Wire 's2' defined in module 'main' is unused (neither read nor assigned).
wire s2,s1,s0; //Registros do signature
|
halcheck: *W,URAWIR (./main.v,13|0): Wire 's1' defined in module 'main' is unused (neither read nor assigned).
wire s2,s1,s0; //Registros do signature
|
halcheck: *W,URAWIR (./main.v,13|0): Wire 's0' defined in module 'main' is unused (neither read nor assigned).
reg [7:0] count; //Conferir contador do pass_fail
|
halcheck: *W,URAREG (./main.v,12|0): Local register variable 'count' defined in module 'main' is unused (neither read nor assigned).
MISR MISR(.CLK(CLK),.e0(scan_out),.e1(out_synced_d),.e2(out_sync_err_d),.h0(h0),.h1(h1),.h2(h2));
|
halcheck: *W,VERREP (./main.v,19|0): Repeated usage of identifier or label name 'MISR'.
halcheck: (./MISR.v,3): Previously declared here.
module main(CLK,RST,bist_start,bist_end,pass_fail,in_k,in_j,in_en,out_synced_d,out_sync_err_d);
|
halcheck: *W,MULTMS (./main.v,3|0): Multiple timescales exist in the design.
halcheck: (./main.v,3): Module 'main' has timeunit/timeprecesion in 1ns/1ps.
halcheck: (./Bist_Control.v,3): Module 'Bist_control' has timeunit/timeprecesion in 1ns/100ps.
halcheck: Total errors   = 0.
halcheck: Total warnings = 535.

  ==========================================================================
Performing synthesizability checks 

cfe64(64): 20.09-s001: (c) Copyright 1995-2020 Cadence Design Systems, Inc.
halsynth: Loading design snapshot....
halsynth: Traversing design hierarchy....
  DFS1 \fs_state_reg[2] (.C (clk), .D (n_19), .SD (n_1), .SE (scan_en),
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,18|0): Component instance is not fully bound (fs_state_reg[2]).
  JKS3 \fs_state_reg[1] (.C (clk), .J (n_17), .K (n_10), .SD (n_0), .SE
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,20|0): Component instance is not fully bound (fs_state_reg[1]).
  OAI310 g935__2398(.A (n_6), .B (fs_state[0]), .C (fs_state[2]), .D
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,22|0): Component instance is not fully bound (g935__2398).
  NAND20 g937__5107(.A (n_14), .B (n_8), .Q (n_20));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,24|0): Component instance is not fully bound (g937__5107).
  INV2 g938(.A (n_18), .Q (n_19));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,25|0): Component instance is not fully bound (g938).
  AOI221 g940__6260(.A (n_12), .B (n_17), .C (fs_state[2]), .D (n_16),
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,26|0): Component instance is not fully bound (g940__6260).
  DFS1 \fs_state_reg[0] (.C (clk), .D (n_16), .SD (scan_in), .SE
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,28|0): Component instance is not fully bound (fs_state_reg[0]).
  NOR30 g939__4319(.A (n_4), .B (fs_state[0]), .C (n_9), .Q (synced_d));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,30|0): Component instance is not fully bound (g939__4319).
  INV0 g942(.A (n_13), .Q (n_14));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,31|0): Component instance is not fully bound (g942).
  AOI220 g943__8428(.A (n_12), .B (n_11), .C (fs_state[1]), .D
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,32|0): Component instance is not fully bound (g943__8428).
  NOR21 g944__5526(.A (rst), .B (n_11), .Q (n_17));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,34|0): Component instance is not fully bound (g944__5526).
  INV2 g945(.A (n_16), .Q (n_10));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,35|0): Component instance is not fully bound (g945).
  AOI210 g946__6783(.A (fs_state[1]), .B (k), .C (n_5), .Q (n_9));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,36|0): Component instance is not fully bound (g946__6783).
  NOR31 g947__3680(.A (n_7), .B (n_8), .C (rst), .Q (n_16));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,37|0): Component instance is not fully bound (g947__3680).
  NAND22 g949__1617(.A (n_7), .B (n_6), .Q (n_11));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,38|0): Component instance is not fully bound (g949__1617).
  NOR20 g948__2802(.A (j), .B (n_8), .Q (n_5));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,39|0): Component instance is not fully bound (g948__2802).
  IMUX21 g950__1705(.A (n_4), .B (fs_state[2]), .S (fs_state[1]), .Q
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,40|0): Component instance is not fully bound (g950__1705).
  INV0 g951(.A (n_3), .Q (n_6));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,42|0): Component instance is not fully bound (g951).
  NAND20 g953__5122(.A (k), .B (rx_en), .Q (n_8));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,43|0): Component instance is not fully bound (g953__5122).
  NAND20 g952__8246(.A (j), .B (rx_en), .Q (n_3));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,44|0): Component instance is not fully bound (g952__8246).
  INV3 g955(.A (fs_state[0]), .Q (n_7));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,45|0): Component instance is not fully bound (g955).
  INV2 g954(.A (fs_state[2]), .Q (n_4));
|
halsynth: *W,UNCINW (./circuito_scan_syn.v,46|0): Component instance is not fully bound (g954).
  wire synced_d, sync_err_d, scan_out;
|
halsynth: *W,UNDRIV (./circuito_scan_syn.v,13|0): Primary output/inout 'synced_d'  is not driven in the module 'circuito12_scan'.
  wire synced_d, sync_err_d, scan_out;
|
halsynth: *W,UNDRIV (./circuito_scan_syn.v,13|0): Primary output/inout 'sync_err_d'  is not driven in the module 'circuito12_scan'.
  wire synced_d, sync_err_d, scan_out;
|
halsynth: *W,UNDRIV (./circuito_scan_syn.v,13|0): Primary output/inout 'scan_out'  is not driven in the module 'circuito12_scan'.
               state <= next_state;
|
halsynth: *N,FSMIDN (./Bist_Control.v,27|0): In module/design-unit 'Bist_control', FSM for state register 'state' has been recognized.
    always @(posedge CLK or posedge RESET)
|
halsynth: *W,EXTSEQ (./Bist_Control.v,18|0): Extraneous logic is present in the sequential portion of the FSM.
        S0:begin    // Garantido start=0 espera para start=1
|
halsynth: *W,TRNMBT (./Bist_Control.v,60|0): For the specified state '1', the state value changes by more than one bits on transition to state(s): 2.
                    next_state = S1;
|
halsynth: (./Bist_Control.v,62|0): Source HDL information for the error/warning mentioned above.
        S2:if (count_N==N) //funcionamento do contador
|
halsynth: *W,TRNMBT (./Bist_Control.v,80|0): For the specified state '3', the state value changes by more than one bits on transition to state(s): 4.
                next_state = S3;
|
halsynth: (./Bist_Control.v,91|0): Source HDL information for the error/warning mentioned above.
        S4:begin
|
halsynth: *W,TRNMBT (./Bist_Control.v,115|0): For the specified state '5', the state value changes by more than one bits on transition to state(s): 6.
            next_state = S5; 
|
halsynth: (./Bist_Control.v,117|0): Source HDL information for the error/warning mentioned above.
module Bist_control(CLK, RESET, START, OUT, BIST_END, RUNNING,INIT,FINISH);
|
halsynth: *W,EXTFSM (./Bist_Control.v,3|0): Extraneous logic present in module/design-unit 'Bist_control' that encodes an FSM.
output reg pass_fail;
|
halsynth: *W,UNDRIV (./main.v,5|0): Primary output/inout 'pass_fail'  is not driven in the module 'main'.
halsynth: Total errors   = 0.
halsynth: Total warnings = 31.

  ==========================================================================
Performing structural checks 

halstruct(64): 20.09-s001: (c) Copyright 1995-2020 Cadence Design Systems, Inc.
visadev(64): 20.09-s001: (c) Copyright 1995-2020 Cadence Design Systems, Inc.
visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,27): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,31): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,32): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,33): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,34): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,35): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,36): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,37): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,38): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,39): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,40): cds.lib Invalid environment variable ''.

visadev: *W,DLCVAR (/afs/.ist.utl.pt/users/9/0/ist193790/cds.lib,41): cds.lib Invalid environment variable ''.

Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halstruct: *W,TPOUNR (./main.v,18|0): Output 'bist_end' of top-level module is not a register.
circuito12_scan circuito_scan(.clk(CLK),.rst(RST),.k(circ_k),.j(circ_j),.rx_en(circ_en),.synced_d(out_synced_d),.sync_err_d(out_sync_err_d), .scan_en(bist_out),
|
halstruct: *W,TPOUNR (./main.v,15|0): Output 'out_synced_d' of top-level module is not a register.
circuito12_scan circuito_scan(.clk(CLK),.rst(RST),.k(circ_k),.j(circ_j),.rx_en(circ_en),.synced_d(out_synced_d),.sync_err_d(out_sync_err_d), .scan_en(bist_out),
|
halstruct: *W,TPOUNR (./main.v,15|0): Output 'out_sync_err_d' of top-level module is not a register.
module Bist_control(CLK, RESET, START, OUT, BIST_END, RUNNING,INIT,FINISH);
|
halstruct: *W,SYNASN (./Bist_Control.v,3|0): The module/design-unit 'Bist_control' contains synchronous as well as asynchronous logic.
halstruct: (./Bist_Control.v,142): One instance/occurence of asynchronous logic at 'main.Bist.next_state'.
halstruct: (./Bist_Control.v,27): One instance/occurence of synchronous logic at 'main.Bist.state'.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halstruct: *W,UNCONO (./main.v,18|0): Port 'RUNNING' (which is being used as an output) of entity/module 'Bist_control' is being driven inside the design, but not connected (either partially or completely) in its instance 'main.Bist'.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halstruct: *W,UNCONO (./main.v,18|0): Port 'INIT' (which is being used as an output) of entity/module 'Bist_control' is being driven inside the design, but not connected (either partially or completely) in its instance 'main.Bist'.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halstruct: *W,UNCONO (./main.v,18|0): Port 'FINISH' (which is being used as an output) of entity/module 'Bist_control' is being driven inside the design, but not connected (either partially or completely) in its instance 'main.Bist'.
MISR MISR(.CLK(CLK),.e0(scan_out),.e1(out_synced_d),.e2(out_sync_err_d),.h0(h0),.h1(h1),.h2(h2));
|
halstruct: *W,UNCONO (./main.v,19|0): Port 'h0' (which is being used as an output) of entity/module 'MISR' is being driven inside the design, but not connected (either partially or completely) in its instance 'main.MISR'.
MISR MISR(.CLK(CLK),.e0(scan_out),.e1(out_synced_d),.e2(out_sync_err_d),.h0(h0),.h1(h1),.h2(h2));
|
halstruct: *W,UNCONO (./main.v,19|0): Port 'h1' (which is being used as an output) of entity/module 'MISR' is being driven inside the design, but not connected (either partially or completely) in its instance 'main.MISR'.
MISR MISR(.CLK(CLK),.e0(scan_out),.e1(out_synced_d),.e2(out_sync_err_d),.h0(h0),.h1(h1),.h2(h2));
|
halstruct: *W,UNCONO (./main.v,19|0): Port 'h2' (which is being used as an output) of entity/module 'MISR' is being driven inside the design, but not connected (either partially or completely) in its instance 'main.MISR'.
circuito12_scan circuito_scan(.clk(CLK),.rst(RST),.k(circ_k),.j(circ_j),.rx_en(circ_en),.synced_d(out_synced_d),.sync_err_d(out_sync_err_d), .scan_en(bist_out),
|
halstruct: *W,DIFCLK (./main.v,15|0): Clock 'CLK' is being renamed to 'clk'.
        x1 <= 1;
|
halstruct: *W,FFWNSR (./LFSR.v,20|0): Flip-flop 'x1' does not have any set or reset.
input CLK,RST,bist_start,in_k,in_j,in_en;
|
halstruct: *N,CLKINF (./main.v,4|0): Signal 'main.CLK' was inferred as clock.
halstruct: (./main.v,4): Clock source is signal 'main.CLK'.
halstruct: (./LFSR.v,20): Drives the flip-flop 'main.LFSR_in.x1'.
        x1 <= 1;
|
halstruct: *W,RSTDAT (./LFSR.v,20|0): Reset signal 'main.RST' drives the data pin of flip-flop 'main.LFSR_in.x1'.
        x2 <= 1;
|
halstruct: *W,FFWNSR (./LFSR.v,21|0): Flip-flop 'x2' does not have any set or reset.
        x2 <= 1;
|
halstruct: *W,RSTDAT (./LFSR.v,21|0): Reset signal 'main.RST' drives the data pin of flip-flop 'main.LFSR_in.x2'.
        x0 <= 1;
|
halstruct: *W,FFWNSR (./LFSR.v,19|0): Flip-flop 'x0' does not have any set or reset.
        x0 <= 1;
|
halstruct: *W,RSTDAT (./LFSR.v,19|0): Reset signal 'main.RST' drives the data pin of flip-flop 'main.LFSR_in.x0'.
             OUT = 0;
|
halstruct: *W,SYNPRT (./Bist_Control.v,144|0): Output port 'OUT' is assigned asynchronously.
             BIST_END = 0;
|
halstruct: *W,SYNPRT (./Bist_Control.v,145|0): Output port 'BIST_END' is assigned asynchronously.
             RUNNING = 0;
|
halstruct: *W,SYNPRT (./Bist_Control.v,143|0): Output port 'RUNNING' is assigned asynchronously.
             INIT = 0;
|
halstruct: *W,SYNPRT (./Bist_Control.v,146|0): Output port 'INIT' is assigned asynchronously.
             FINISH = 0;
|
halstruct: *W,SYNPRT (./Bist_Control.v,147|0): Output port 'FINISH' is assigned asynchronously.
               state <= next_state;
|
halstruct: *W,ASNRST (./Bist_Control.v,27|0): Flip-flop 'main.Bist.state' has 'active_high' asynchronous set/reset 'RESET' as against the recommended 'active_low' style.
               state <= next_state;
|
halstruct: *N,FFASRT (./Bist_Control.v,27|0): Flip-flop 'state' has an asynchronous reset 'RESET'.
Bist_control Bist(.CLK(CLK), .RESET(RST), .START(bist_start), .OUT(bist_out), .BIST_END(bist_end), .RUNNING(),.INIT(),.FINISH());//INit deve reiniciar o scan,Finish � util para saber quando fazer pass_fail
|
halstruct: *W,DIFRST (./main.v,18|0): Set/Reset 'RST' is being renamed to 'RESET'.
                        count_N <= count_N + 8'd1;  
|
halstruct: *W,ASNRST (./Bist_Control.v,41|0): Flip-flop 'main.Bist.count_N' has 'active_high' asynchronous set/reset 'RESET' as against the recommended 'active_low' style.
                        count_N <= count_N + 8'd1;  
|
halstruct: *N,FFASRT (./Bist_Control.v,41|0): Flip-flop 'count_N' has an asynchronous reset 'RESET'.
                        count_M <= count_M + 8'd1;
|
halstruct: *W,ASNRST (./Bist_Control.v,35|0): Flip-flop 'main.Bist.count_M' has 'active_high' asynchronous set/reset 'RESET' as against the recommended 'active_low' style.
                        count_M <= count_M + 8'd1;
|
halstruct: *N,FFASRT (./Bist_Control.v,35|0): Flip-flop 'count_M' has an asynchronous reset 'RESET'.
    h0 <= !(e2 || h1);
|
halstruct: *W,FFWNSR (./MISR.v,9|0): Flip-flop 'h0' does not have any set or reset.
    h1 <= !(e1 || h0);
|
halstruct: *W,FFWNSR (./MISR.v,10|0): Flip-flop 'h1' does not have any set or reset.
    h2 <= !(e0 || !(h2 || !(h1||h0))); 
|
halstruct: *W,FFWNSR (./MISR.v,11|0): Flip-flop 'h2' does not have any set or reset.
module main(CLK,RST,bist_start,bist_end,pass_fail,in_k,in_j,in_en,out_synced_d,out_sync_err_d);
|
halstruct: *W,ATLGLC (./main.v,3|0): Glue logic inferred in top-level module/design-unit 'main'.
halstruct: (./main.v,31): HDL-statement inferred as glue logic.
halstruct: (./main.v,32): HDL-statement inferred as glue logic.
halstruct: (./main.v,33): HDL-statement inferred as glue logic.
module main(CLK,RST,bist_start,bist_end,pass_fail,in_k,in_j,in_en,out_synced_d,out_sync_err_d);
|
halstruct: *N,NUMDFF (./main.v,3|0): Number of single-bit D flip-flops present in the hierarchy is 17.
halstruct: Design facts generated in 'hal.design_facts'.
halstruct: Total errors   = 0.
halstruct: Total warnings = 30.

  ==========================================================================

Analysis summary :

 Warnings : (765)
  ASNRST (3)      ATLGLC (1)      CTLCHR (232)    DIFCLK (1)     
  DIFFMN (2)      DIFRST (1)      DLCVAR (180)    EXTFSM (1)     
  EXTSEQ (1)      FFWNSR (6)      IMPDTC (58)     INTTOB (53)    
  KEYWOD (1)      LCVARN (43)     MAXLEN (7)      MULTMS (1)     
  NBGEND (4)      NOBLKN (5)      POIASG (2)      PRTSNP (1)     
  REVROP (1)      RSTDAT (3)      STYVAL (4)      SYNASN (1)     
  SYNPRT (5)      TPOUNR (3)      TRNMBT (3)      TRUNCZ (66)    
  UASWIR (20)     UELOPR (2)      ULCMPE (10)     UNCINW (22)    
  UNCONN (3)      UNCONO (6)      UNDRIV (4)      URAREG (2)     
  URAWIR (3)      URDWIR (3)      VERREP (1)     

 Notes    : (60)
  ALOWID (1)      CDNOTE (5)      CLKINF (1)      CUVBPD (22)    
  DECLIN (10)     FFASRT (3)      FSMIDN (1)      IDLENG (11)    
  NUMDFF (1)      PRTCNT (5)     

Analysis complete.

 ==========================================================================

